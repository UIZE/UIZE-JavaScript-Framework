This is a TO DO document for modules under the =Uize.Data= namespace.

Uize.Data.safeLookup
	- performs a lookup in a lookup object that may not be a safe lookup, so it handles the problems keys
	- perhaps there should also be a similar Uize.Data.keyIn (or Uize.Data.keyExists) method
	- possible implementation
		................................................................................
		var _problemKeys = {constructor:1,toString:1,valueOf:1};
		Uize.Data.safeLookup = function (_lookup,_key) {
			if (_problemKeys [_key]) {
				var
					_value = _lookup [_key],
					_lookupConstructor = _lookup.constructor
				;
				return _lookupConstructor && _value == _lookupConstructor.prototype [_key] ? _undefined : _value;
			} else {
				return _lookup [_key];
			}
		};
		................................................................................

................................................................................
Uize.Data.makeValueTransformerGenerator = function (_valueTransformer) {
	_valueTransformer = Uize.resolveTransformer (_valueTransformer);
	var _generator = function () {
		if (arguments.length) {
			var _arguments = Uize.push ([0],arguments);
			return function (_value) {
				_arguments [0] = _value;
				return _valueTransformer.apply (0,_arguments);
			};
		} else {
			return _valueTransformer;
		}
	};
	_generator.exec = _valueTransformer;
	return _generator;
};
................................................................................

Uize.Data.resolveSourceAndTarget
	................................................................................
	_package.resolveSourceAndTarget = function (_source,_target,_targetDefault,_keysMayChange,_emptyOutTarget) {
		if (_target === _undefined) _target = _targetDefault;
		if (typeof _source == 'number') {
			_source = new Array (_source);
			if (typeof _target != 'object') _target = _source;
		} else if (typeof _target != 'object') {
			_target = !_target ? _source : Uize.isArray (_source) ? [] : {};
		}
		if (_keysMayChange && _target == _source)
			_source = Uize.isArray (_source) ? _source.concat () : Uize.copy (_source)
		;
		_target != _source && _emptyOutTarget && Uize.emptyOut (_target);
		return {source:_source,target:_target};
	};
	................................................................................

	usage...

	................................................................................
	var _sourceAndTarget = Uize.Data.resolveSourceAndTarget (_source,_target,true);
	_source = _sourceAndTarget._source;
	_target = _sourceAndTarget._target;
	................................................................................

Uize.Data.hasCircularity
	- tests to see if the object contains circular references / reference loops
	- for implementation, use object tagging

Uize.Data.mapKeys
	- lets you rename keys in an object

Uize.Data.mapKeyValues
	- lets you rename keys and transform values in an object


