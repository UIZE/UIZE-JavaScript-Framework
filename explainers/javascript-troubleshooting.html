<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Javascript Troubleshooting | Documentation | UIZE JavaScript Framework</title>
	<meta name="keywords" content="UIZE JavaScript Framework Documentation "/>
	<meta name="description" content="This document discusses various tips and techniques for troubleshooting projects and Web applications developed using the UIZE JavaScript Framework."/>
	<link rel="alternate" type="application/rss+xml" title="UIZE JavaScript Framework - Latest News" href="http://www.uize.com/latest-news.rss"/>
	<link rel="stylesheet" href="../css/page.css"/>
	<link rel="stylesheet" href="../css/page.simpledoc.css"/>
</head>

<body>

<script type="text/javascript" src="../js/Uize.js"></script>

<h1 class="document-title">
	<a id="page-homeLink" href="../index.html" title="UIZE JavaScript Framework home"></a>
	
	<a href="../javascript-explainers.html" class="breadcrumb breadcrumbWithArrow">EXPLAINERS</a>
	Javascript Troubleshooting

</h1>

<div class="main">
<div id="page_contents" class="contents-tree-shell">
<ul>
	<li>Contents
		<ul>
			<li><a href="#1" title="This document discusses various tips and techniques for troubleshooting projects and Web applications developed using the UIZE JavaScript Framework.">1. Introduction</a></li>
			<li><a href="#2" title="While developing your code, it is always best to use source JavaScript code rather than scrunched JavaScript code.">2. Use Source JavaScript When Troubleshooting</a></li>
			<li><a href="#3" title="As good as tools like Firebug become, there are still times when JavaScript&apos;s tried and tested built-in alert statement provides a good fallback for quick testing across multiple different browsers.">3. Basic Troubleshooting With Alerts</a>
				<ul>
					<li><a href="#3_1" title="The Uize.Class base class implements a toString Intrinsic Method that returns a summary for instances of Uize.Class subclasses, and for Uize.Class subclasses.">3.1. Alerting Summary Info for Instances or Classes</a></li>
					<li><a href="#3_2" title="The Uize.Class base class implements a valueOf Intrinsic Method that returns the value of the value state property - for instances of Uize.Class subclasses as well as Uize.Class subclasses.">3.2. Alerting Values of Instances or Classes</a></li>
				</ul>
			</li>
			<li><a href="#4" title="Firebug is an indispensable tool when troubleshooting JavaScript code. There are certain tricks specific to the UIZE JavaScript Framework that will aid in your Firebug troubleshooting.">4. Tips for Troubleshooting in Firebug</a>
				<ul>
					<li><a href="#4_1" title="Firebug provides a powerful DOM inspector that not only lets you traverse the document&apos;s node hierarchy, but also lets you inspect user-defined properties and functions.">4.1. Traversing the Widget Tree in Firebug</a></li>
					<li><a href="#4_2" title="When using the DOM inspector in Firebug to peruse the widget tree, any property that is an instance of a Uize.Class subclass will have the module name for its class displayed to the right of the property.">4.2. Display of Types in Firebug's DOM Inspector</a></li>
					<li><a href="#4_3" title="Just as with Alerting Summary Info for Instances or Classes, summary info for instances of Uize.Class subclasses as well as Uize.Class subclasses can be conveniently logged to the Firebug console using Firebug&apos;s console.log method.">4.3. Logging Summary Info for Instances or Classes to Firebug's Console</a></li>
					<li><a href="#4_4" title="Just as with Alerting Values of Instances or Classes, values for instances of Uize.Class subclasses as well as Uize.Class subclasses can be conveniently logged to the Firebug console using Firebug&apos;s console.log method.">4.4. Logging Values of Instances or Classes to Firebug's Console</a></li>
				</ul>
			</li>
			<li><a href="#5" title="Certain kinds of problems can arise specifically with scrunched code and not be present with source code.">5. Scrunch-related Problems</a>
				<ul>
					<li><a href="#5_1" title="Missing semicolons at the end of statements can lead to JavaScript syntax errors when JavaScript code is scrunched and consecutive lines that used to be separated by linebreaks are compacted together.">5.1. Missing Semicolons</a></li>
					<li><a href="#5_2" title="Accessing a private identifier as though it were a public identifier will work in source code but will almost certainly not work when the code is scrunched.">5.2. Accessing Private Identifiers as Publics</a>
						<ul>
							<li><a href="#5_2_1" title="One less-than-obvious access of privates that can occur is with subclasses.">5.2.1. Accessing a Superclass' State Properties</a></li>
						</ul>
					</li>
					<li><a href="#5_3" title="Accidentally assigning globals can have interesting interactions with the scrunching process.">5.3. Accidental Globals and Scrunching</a></li>
					<li><a href="#5_4" title="It can sometimes - yet rarely - happen that source code of a subclass may conflict with source code of a superclass, if the same private identifier name is used in each, but for different purposes.">5.4. Private Collisions</a></li>
					<li><a href="#5_5" title="The Scruncher does not enter string literals. This means that any code contained inside string literals will not be scrunched.">5.5. Private Identifiers Inside String Literals</a>
						<ul>
							<li><a href="#5_5_1" title="Make public the identifiers that need to be accessed from the code inside string literals, as in...">5.5.1. Avoid Privates</a></li>
							<li><a href="#5_5_2" title="Use the trick to &quot;pipe&quot; the scrunched name into dynamically constructed JavaScript code, as in...">5.5.2. Pipe the Privates Through</a></li>
						</ul>
					</li>
				</ul>
			</li>
			<li><a href="#6" title="Accidental globals are variables that are accidentally assigned in the global scope - usually the result of a bug / oversight.">6. Accidental Globals</a>
				<ul>
					<li><a href="#6_1" title="The kinds of problem situations that can arise as a result of accidental global include...">6.1. The Problems They Create</a>
						<ul>
							<li><a href="#6_1_1" title="Different instances of the same closure can stomp over state that wasn&apos;t intended to be shared.">6.1.1. Collisions Between Different Instances of a Closure</a></li>
							<li><a href="#6_1_2" title="Two different pieces of code - possibly in the same module or from completely different modules in use by the page - can stomp over state that wasn&apos;t intended to be shared.">6.1.2. Collisions Between Disparate Code</a>
								<ul>
									<li><a href="#6_1_2_1" title="In one scenario, two accidental globals have different names in source mode but get scrunched to the same identifier in scrunched mode.">6.1.2.1. Works in Source, Fails in Scrunched</a></li>
									<li><a href="#6_1_2_2" title="In another scenario, two accidental globals may &quot;collide&quot; when using source / unscrunched code, but may not collide when the scrunched version of the code is used.">6.1.2.2. Fails in Source, Works in Scrunched</a></li>
								</ul>
							</li>
							<li><a href="#6_1_3" title="Code inside a module can accidentally assign a value on a global variable that is also used by the page code, when the module actually needs to be using a local scope variable.">6.1.3. Collisions With Page Code</a></li>
						</ul>
					</li>
					<li><a href="#6_2" title="The most obvious way to assign an accidental global is to simply forget the var keyword in front of a plain old variable declaration / assignment.">6.2. How They Creep In</a>
						<ul>
							<li><a href="#6_2_1" title="Consider the following somewhat innocent looking compound var statement...">6.2.1. Incorrect Semicolon in Compound var Statement</a></li>
							<li><a href="#6_2_2" title="A slightly more obvious, yet surprisingly easy-to-make mistake is to omit a var keyword in a loop, particularly with for...in loops.">6.2.2. Missing var statement in Loops</a></li>
						</ul>
					</li>
					<li><a href="#6_3" title="Accidental globals can be spotted by keeping an eye on the DOM in a debugging tool such as Firebug.">6.3. How to Spot Accidental Globals</a>
						<ul>
							<li><a href="#6_3_1" title="In order to be certain that you&apos;ve spotted all the lurking accidental globals, you may need to pound away at the functionality in your pages.">6.3.1. Thorough Interaction</a></li>
							<li><a href="#6_3_2" title="Keep Firebug open while browsing pages of your site and have the DOM tab selected.">6.3.2. Using Firebug</a></li>
						</ul>
					</li>
					<li><a href="#6_4" title="It can be hard to fix an accidental global, because there&apos;s no easy way to know where its assignment is originating from.">6.4. Fixing Accidental Globals</a></li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
</div>

<div class="contents0">
	<a name="1"></a>
	<h1 class="heading1" title="1. Introduction"><span class="headingNumber"><a href="#1" title="1. Introduction">1</a>. </span>Introduction</h1>
	<div class="contents1">
		<p>This document discusses various tips and techniques for troubleshooting projects and Web applications developed using the UIZE JavaScript Framework.</p>
	</div>
	
	<a name="2"></a>
	<h1 class="heading1" title="2. Use Source JavaScript When Troubleshooting"><span class="headingNumber"><a href="#2" title="2. Use Source JavaScript When Troubleshooting">2</a>. </span>Use Source JavaScript When Troubleshooting</h1>
	<div class="contents1">
		<p>While developing your code, it is always best to use source JavaScript code rather than scrunched JavaScript code.</p>
		
		<p>Scrunching JavaScript code obfuscates identifier names and can make JavaScript error messages rather cryptic, rendering them pretty much useless when trying to track down tricky issues. Make sure to develop using source code - not only for your own application's code, but also the various modules of the UIZE JavaScript Framework.</p>
	</div>
	
	<a name="3"></a>
	<h1 class="heading1" title="3. Basic Troubleshooting With Alerts"><span class="headingNumber"><a href="#3" title="3. Basic Troubleshooting With Alerts">3</a>. </span>Basic Troubleshooting With Alerts</h1>
	<div class="contents1">
		<p>As good as tools like <a href="http://getfirebug.com" target="_blank" class="externalSiteLink">Firebug</a> become, there are still times when JavaScript's tried and tested built-in <code>alert</code> statement provides a good fallback for quick testing across multiple different browsers.</p>
		
		<p>The UIZE JavaScript Framework provides two convenient facilities that help with this classic / old school / original flavor style of debugging.</p>
		
		<a name="3_1"></a>
		<h2 class="heading2" title="3. Basic Troubleshooting With Alerts -&gt; 3.1. Alerting Summary Info for Instances or Classes"><span class="headingNumber"><a href="#3" title="3. Basic Troubleshooting With Alerts">3</a>.<a href="#3_1" title="3. Basic Troubleshooting With Alerts -&gt; 3.1. Alerting Summary Info for Instances or Classes">1</a>. </span>Alerting Summary Info for Instances or Classes</h2>
		<div class="contents2">
			<p>The <code><a href="../reference/Uize.Class.html">Uize.Class</a></code> base class implements a <code>toString Intrinsic Method</code> that returns a summary for instances of <code><a href="../reference/Uize.Class.html">Uize.Class</a></code> subclasses, and for <code><a href="../reference/Uize.Class.html">Uize.Class</a></code> subclasses.</p>
			
			<p>Because this method is implemented in the <code><a href="../reference/Uize.Class.html">Uize.Class</a></code> base class, all <code><a href="../reference/Uize.Class.html">Uize.Class</a></code> subclasses get to inherit it. Thanks to this method, you can conveniently display summary info for instances of <code><a href="../reference/Uize.Class.html">Uize.Class</a></code> subclasses as well as <code><a href="../reference/Uize.Class.html">Uize.Class</a></code> subclasses using the <code>alert</code> statement.</p>
			
			<p><span class="allCaps">EXAMPLE 1</span></p>
			
			
<pre class="sample-code">alert (page.children.slider);
</pre>
			
			<p>In the above example, if the <code>page</code> widget has a <code>slider</code> child widget that is an instance of the class <code><a href="../reference/Uize.Widget.Bar.Slider.html">Uize.Widget.Bar.Slider</a></code>, then the output of the <code>alert</code> statement could look something like...</p>
			
			<p><span class="allCaps">EXAMPLE OUTPUT</span></p>
			
			
<pre class="sample-code">[object Uize.Widget.Bar.Slider]

built : true
busy : inherit
busyInherited : false
confirm : undefined
container : undefined
decimalPlacesToDisplay : undefined
enabled : inherit
enabledInherited : true
html : undefined
idPrefix : page_slider
idPrefixConstruction : concatenated
inDrag : false
increments : 1
inform : undefined
insertionMode: undefined
localized : undefined
maxValidValue : undefined
maxValue : 200
minValidValue : undefined
minValue : 0
name : slider
nodeMap : undefined
orientation : vertical
parent : [class UizeSite.Page.Example]
restTime : 250
scaleFunc : [object Function]
value : 0
valueFunc : [object Function]
wired : true
</pre>
			
			<p><span class="allCaps">EXAMPLE 2</span></p>
			
			
<pre class="sample-code">alert (page.children.slider.Class);
</pre>
			
			<p>In the above example, if the <code>page</code> widget has a <code>slider</code> child widget that is an instance of the class <code><a href="../reference/Uize.Widget.Bar.Slider.html">Uize.Widget.Bar.Slider</a></code>, then the output of the <code>alert</code> statement could look something like...</p>
			
			<p><span class="allCaps">EXAMPLE OUTPUT</span></p>
			
			
<pre class="sample-code">[class Uize.Widget.Bar.Slider]

built : true
busy : inherit
busyInherited : false
confirm : undefined
container : undefined
decimalPlacesToDisplay : undefined
enabled : inherit
enabledInherited : true
html : undefined
idPrefix : undefined
idPrefixConstruction : undefined
inDrag : false
increments : 1
inform : undefined
insertionMode: undefined
localized : undefined
maxValidValue : undefined
maxValue : 100
minValidValue : undefined
minValue : 0
name : undefined
nodeMap : undefined
orientation : vertical
parent : undefined
restTime : 250
scaleFunc : [object Function]
value : 0
valueFunc : [object Function]
wired : false
</pre>
		</div>
		
		<a name="3_2"></a>
		<h2 class="heading2" title="3. Basic Troubleshooting With Alerts -&gt; 3.2. Alerting Values of Instances or Classes"><span class="headingNumber"><a href="#3" title="3. Basic Troubleshooting With Alerts">3</a>.<a href="#3_2" title="3. Basic Troubleshooting With Alerts -&gt; 3.2. Alerting Values of Instances or Classes">2</a>. </span>Alerting Values of Instances or Classes</h2>
		<div class="contents2">
			<p>The <code><a href="../reference/Uize.Class.html">Uize.Class</a></code> base class implements a <code>valueOf Intrinsic Method</code> that returns the value of the <code>value</code> state property - for instances of <code><a href="../reference/Uize.Class.html">Uize.Class</a></code> subclasses as well as <code><a href="../reference/Uize.Class.html">Uize.Class</a></code> subclasses.</p>
			
			<p>Because this method is implemented in the <code><a href="../reference/Uize.Class.html">Uize.Class</a></code> base class, all <code><a href="../reference/Uize.Class.html">Uize.Class</a></code> subclasses get to inherit it. For any class that implements a <code>value</code> state property, the value of an instance can be displayed in an alert dialog using a convenient shorthand. This can be done by prepending a "+" (plus sign) to the instance reference for classes that implement a number type value, or by appending a <code>+ ''</code> to the instance reference for classes that implement a string type value.</p>
			
			<p><span class="allCaps">EXAMPLE 1</span></p>
			
			
<pre class="sample-code">alert (+page.children.slider);
</pre>
			
			<p><span class="allCaps">EXAMPLE 2</span></p>
			
			
<pre class="sample-code">alert (page.children.imageWipe + '');
</pre>
		</div>
	</div>
	
	<a name="4"></a>
	<h1 class="heading1" title="4. Tips for Troubleshooting in Firebug"><span class="headingNumber"><a href="#4" title="4. Tips for Troubleshooting in Firebug">4</a>. </span>Tips for Troubleshooting in Firebug</h1>
	<div class="contents1">
		<p><a href="http://getfirebug.com" target="_blank" class="externalSiteLink">Firebug</a> is an indispensable tool when troubleshooting JavaScript code. There are certain tricks specific to the UIZE JavaScript Framework that will aid in your <a href="http://getfirebug.com" target="_blank" class="externalSiteLink">Firebug</a> troubleshooting.</p>
		
		<a name="4_1"></a>
		<h2 class="heading2" title="4. Tips for Troubleshooting in Firebug -&gt; 4.1. Traversing the Widget Tree in Firebug"><span class="headingNumber"><a href="#4" title="4. Tips for Troubleshooting in Firebug">4</a>.<a href="#4_1" title="4. Tips for Troubleshooting in Firebug -&gt; 4.1. Traversing the Widget Tree in Firebug">1</a>. </span>Traversing the Widget Tree in Firebug</h2>
		<div class="contents2">
			<p><a href="http://getfirebug.com" target="_blank" class="externalSiteLink">Firebug</a> provides a powerful DOM inspector that not only lets you traverse the document's node hierarchy, but also lets you inspect user-defined properties and functions.</p>
			
			<p>By using the DOM inspector, you can traverse the JavaScript widget tree for a page that uses the UIZE JavaScript Framework. On a typical page you will have a page widget at the root of the widget hierarchy. Finding this in the DOM inspector, you can expand it and inspect its properties. In order to dig deeper into the widget tree, you can locate the <code>children</code> property of the page widget and expand it too. For each child widget of the page widget you can do the same. You can keep sleuthing like this, digging as deep as you need to, to ultimately find the "widget of interest" that is a suspect in the code crime you are investigating.</p>
			
			<p>At any stage in this process, you can inspect the values of state properties for a widget instance. Note that the state properties will be represented using their private names (ie. prefixed with an underscore).</p>
		</div>
		
		<a name="4_2"></a>
		<h2 class="heading2" title="4. Tips for Troubleshooting in Firebug -&gt; 4.2. Display of Types in Firebug&apos;s DOM Inspector"><span class="headingNumber"><a href="#4" title="4. Tips for Troubleshooting in Firebug">4</a>.<a href="#4_2" title="4. Tips for Troubleshooting in Firebug -&gt; 4.2. Display of Types in Firebug&apos;s DOM Inspector">2</a>. </span>Display of Types in Firebug's DOM Inspector</h2>
		<div class="contents2">
			<p>When using the DOM inspector in <a href="http://getfirebug.com" target="_blank" class="externalSiteLink">Firebug</a> to peruse the widget tree, any property that is an instance of a <code><a href="../reference/Uize.Class.html">Uize.Class</a></code> subclass will have the module name for its class displayed to the right of the property.</p>
			
			<p><span class="allCaps">EXAMPLE</span></p>
			
			
<pre class="sample-code">page                  Uize.Widget.Page instanceId=uizeGuid1 _children=Object
</pre>
			
			<p>This can be particularly useful when inspecting the <code>children</code> property of a widget to peruse its child widgets. In this case, the widget class for each child widget will be displayed to the right of the child widget name, as in...</p>
			
			<p><span class="allCaps">EXAMPLE</span></p>
			
			
<pre class="sample-code">imageWipe             Uize.Widget.ImageWipe ...
paramsInspector       UizeSite.ParamsInspector ...
performWipe           Uize.Widget.Button ...
</pre>
		</div>
		
		<a name="4_3"></a>
		<h2 class="heading2" title="4. Tips for Troubleshooting in Firebug -&gt; 4.3. Logging Summary Info for Instances or Classes to Firebug&apos;s Console"><span class="headingNumber"><a href="#4" title="4. Tips for Troubleshooting in Firebug">4</a>.<a href="#4_3" title="4. Tips for Troubleshooting in Firebug -&gt; 4.3. Logging Summary Info for Instances or Classes to Firebug&apos;s Console">3</a>. </span>Logging Summary Info for Instances or Classes to Firebug's Console</h2>
		<div class="contents2">
			<p>Just as with <a href="#3_1">Alerting Summary Info for Instances or Classes</a>, summary info for instances of <code><a href="../reference/Uize.Class.html">Uize.Class</a></code> subclasses as well as <code><a href="../reference/Uize.Class.html">Uize.Class</a></code> subclasses can be conveniently logged to the <a href="http://getfirebug.com" target="_blank" class="externalSiteLink">Firebug</a> console using Firebug's <code>console.log</code> method.</p>
			
			<p>Unlike JavaScript's built-in <code>alert</code> function, however, Firebug's <code>console.log</code> method does not call the <code>toString Intrinsic Method</code> on its first argument, so you have to call this method explicitly, as in...</p>
			
			<p><span class="allCaps">EXAMPLE 1</span></p>
			
			
<pre class="sample-code">console.log (page.children.slider.toString ());
</pre>
			
			<p><span class="allCaps">EXAMPLE 2</span></p>
			
			
<pre class="sample-code">console.log (Uize.Widget.Bar.Slider.toString ());
</pre>
			
			<p>In both cases, the output that is logged to the <a href="http://getfirebug.com" target="_blank" class="externalSiteLink">Firebug</a> console will look pretty much the same as what you would see in an alert dialog (see <a href="#3_1">Alerting Summary Info for Instances or Classes</a>).</p>
		</div>
		
		<a name="4_4"></a>
		<h2 class="heading2" title="4. Tips for Troubleshooting in Firebug -&gt; 4.4. Logging Values of Instances or Classes to Firebug&apos;s Console"><span class="headingNumber"><a href="#4" title="4. Tips for Troubleshooting in Firebug">4</a>.<a href="#4_4" title="4. Tips for Troubleshooting in Firebug -&gt; 4.4. Logging Values of Instances or Classes to Firebug&apos;s Console">4</a>. </span>Logging Values of Instances or Classes to Firebug's Console</h2>
		<div class="contents2">
			<p>Just as with <a href="#3_2">Alerting Values of Instances or Classes</a>, values for instances of <code><a href="../reference/Uize.Class.html">Uize.Class</a></code> subclasses as well as <code><a href="../reference/Uize.Class.html">Uize.Class</a></code> subclasses can be conveniently logged to the <a href="http://getfirebug.com" target="_blank" class="externalSiteLink">Firebug</a> console using Firebug's <code>console.log</code> method.</p>
			
			<p><span class="allCaps">EXAMPLE 1</span></p>
			
			
<pre class="sample-code">console.log (+page.children.slider);
</pre>
			
			<p><span class="allCaps">EXAMPLE 2</span></p>
			
			
<pre class="sample-code">console.log (page.children.imageWipe + '');
</pre>
		</div>
	</div>
	
	<a name="5"></a>
	<h1 class="heading1" title="5. Scrunch-related Problems"><span class="headingNumber"><a href="#5" title="5. Scrunch-related Problems">5</a>. </span>Scrunch-related Problems</h1>
	<div class="contents1">
		<p>Certain kinds of problems can arise specifically with scrunched code and not be present with source code.</p>
		
		<p>If you encounter a problem with production / scrunched code, switch to using source code in order to obtain a meaningful error message, only to then find that the error is not reproducible, chances are you have a scrunch-related bug on your hands.</p>
		
		<p>There are a number of common mistakes one can make that will be forgiven with source code but not with scrunched code, as outlined below...</p>
		
		<a name="5_1"></a>
		<h2 class="heading2" title="5. Scrunch-related Problems -&gt; 5.1. Missing Semicolons"><span class="headingNumber"><a href="#5" title="5. Scrunch-related Problems">5</a>.<a href="#5_1" title="5. Scrunch-related Problems -&gt; 5.1. Missing Semicolons">1</a>. </span>Missing Semicolons</h2>
		<div class="contents2">
			<p>Missing semicolons at the end of statements can lead to JavaScript syntax errors when JavaScript code is scrunched and consecutive lines that used to be separated by linebreaks are compacted together.</p>
			
			<p>JavaScript interpreters are quite forgiving regarding missing semicolons at the end of statements, and use linebreaks as hints to resolve situations where there might be ambiguity. This forgiving nature can lead to missing semicolons creeping in and not being detected while developing with source code. However, when the code is scrunched and linebreaks are stripped, two lines where a linebreak was serving as a statement terminator suddenly get tacked together to produce something that is syntactically incorrect.</p>
			
			<p><span class="allCaps">SOURCE CODE - IT WORKS</span></p>
			
			
<pre class="sample-code">var _blah = 5

function _myFunction () {}
</pre>
			
			<p><span class="allCaps">SCRUNCHED CODE - IT FAILS!!!</span></p>
			
			
<pre class="sample-code">var _a=5function _b(){}
</pre>
			
			<p>A particularly common place to miss a semicolon is when assigning an anonymous function declaration to a prototype property, as in...</p>
			
			<p><span class="allCaps">INCORRECT</span></p>
			
			
<pre class="sample-code">_classPrototype.myMethod1 = function () {
  // ... ... ...
  // ... ... ...
  // ... ... ...
  // ... ... ...
  // ... ... ...
}

_classPrototype.myMethod2 = function () {
  // ... ... ...
  // ... ... ...
  // ... ... ...
  // ... ... ...
  // ... ... ...
};
</pre>
			
			<p>The semicolon omitted after the first assignment will cause the two assignments to run together when the code is scrunched, causing a JavaScript error. This problem can be easy to miss for a few reasons...</p>
			
			<table class="list">
			<tr valign="top"><td><span style="white-space:nowrap;">1) </span></td><td>A function's implementation could be quite long, so a wide chasm is introduced between the start of the assignment and its end. By the time you get down to the close curly bracket, the assignment aspect of the statement is forgotten.</td></tr>
			<tr valign="top"><td><span style="white-space:nowrap;">2) </span></td><td>Function declarations don't usually end with a semicolon, so one can forget that you're not just declaring a function but also assigning the result of that declaration.</td></tr>
			<tr valign="top"><td><span style="white-space:nowrap;">3) </span></td><td>A function may start off its life as no more than a simple function declaration, and then later it is decided to assign it as a method (private or public) or to some local variable. When turning the function declaration into an assignment, one could easily forget to add that important semicolon at the end.</td></tr>
			</table>
		</div>
		
		<a name="5_2"></a>
		<h2 class="heading2" title="5. Scrunch-related Problems -&gt; 5.2. Accessing Private Identifiers as Publics"><span class="headingNumber"><a href="#5" title="5. Scrunch-related Problems">5</a>.<a href="#5_2" title="5. Scrunch-related Problems -&gt; 5.2. Accessing Private Identifiers as Publics">2</a>. </span>Accessing Private Identifiers as Publics</h2>
		<div class="contents2">
			<p>Accessing a private identifier as though it were a public identifier will work in source code but will almost certainly not work when the code is scrunched.</p>
			
			<p>When application code or some other module of code (such as a different class, or even a subclass) accesses a private identifier, such as a private property or method, then the code will most likely break when it is scrunched. This is because modules are scrunched independently, and so the same private identifier name is very unlikely to be mapped to the same scrunched name across multiple different modules of code. One can consider this a kind of serendipitous slap on the wrist delivered by the Scruncher, because code shouldn't be inappropriately looking at other code's privates - let alone touching them.</p>
			
			<p>The kinds of inappropriate accessing that one may encounter when troubleshooting scrunch-related failures include...</p>
			
			<table class="list">
			<tr valign="top"><td><span style="white-space:nowrap;"><span class="bullet"></span> </span></td><td>an application inappropriately accesses private methods or properties of a class or instance it is using</td></tr>
			<tr valign="top"><td><span style="white-space:nowrap;"><span class="bullet"></span> </span></td><td>a class inappropriately accesses private methods or properties of a helper class it is using</td></tr>
			<tr valign="top"><td><span style="white-space:nowrap;"><span class="bullet"></span> </span></td><td>a subclass inappropriately accesses private methods or properties of its superclass</td></tr>
			</table>
			<a name="5_2_1"></a>
			<h3 class="heading3" title="5. Scrunch-related Problems -&gt; 5.2. Accessing Private Identifiers as Publics -&gt; 5.2.1. Accessing a Superclass&apos; State Properties"><span class="headingNumber"><a href="#5" title="5. Scrunch-related Problems">5</a>.<a href="#5_2" title="5. Scrunch-related Problems -&gt; 5.2. Accessing Private Identifiers as Publics">2</a>.<a href="#5_2_1" title="5. Scrunch-related Problems -&gt; 5.2. Accessing Private Identifiers as Publics -&gt; 5.2.1. Accessing a Superclass&apos; State Properties">1</a>. </span>Accessing a Superclass' State Properties</h3>
			<div class="contents3">
				<p>One less-than-obvious access of privates that can occur is with subclasses.</p>
				
				<p>If a state property is registered in a superclass, with a mapping of public name to private name, then the superclass can reference that state property by its private name. However, a subclass of that superclass may not. Instead, it must use the public name. And, to query the value for a state property registered in the superclass, the subclass must use the <code>get</code> method.</p>
				
				<p>If you reference state properties, properties, or methods of a superclass by private name in the implementation of your subclass, your code will work when using source code but most likely produce errors or erratic behavior when using scrunched code.</p>
			</div>
		</div>
		
		<a name="5_3"></a>
		<h2 class="heading2" title="5. Scrunch-related Problems -&gt; 5.3. Accidental Globals and Scrunching"><span class="headingNumber"><a href="#5" title="5. Scrunch-related Problems">5</a>.<a href="#5_3" title="5. Scrunch-related Problems -&gt; 5.3. Accidental Globals and Scrunching">3</a>. </span>Accidental Globals and Scrunching</h2>
		<div class="contents2">
			<p>Accidentally assigning globals can have interesting interactions with the scrunching process.</p>
			
			<p>Scrunch-related side-effects of accidentally assigned globals are discussed in more detail in the section <a href="#6">Accidental Globals</a>.</p>
		</div>
		
		<a name="5_4"></a>
		<h2 class="heading2" title="5. Scrunch-related Problems -&gt; 5.4. Private Collisions"><span class="headingNumber"><a href="#5" title="5. Scrunch-related Problems">5</a>.<a href="#5_4" title="5. Scrunch-related Problems -&gt; 5.4. Private Collisions">4</a>. </span>Private Collisions</h2>
		<div class="contents2">
			<p>It can sometimes - yet rarely - happen that source code of a subclass may conflict with source code of a superclass, if the same private identifier name is used in each, but for different purposes.</p>
			
			<p>To avoid collisions in private identifier names between a superclass and a subclass when code is scrunched, scrunched identifier prefixes are registered with both the superclass and the subclass that are unique to each. This has the interesting potential side effect that a superclass-subclass collision in a private identifier name could surface only in source code but be guaranteed to never occur with scrunched code, since the names will be the same in the source code but different from one another in the scrunched code.</p>
			
			<p>Fortunately, a problem that occurs in source code is more likely to be detected earlier, because development will be done using source / unscrunched code. However, when writing an implementation for a subclass, you may nevertheless want to crack open the source code for the superclass that you are subclassing - just to be certain. This is pretty typical, anyway, since it is useful to understand the implementation of a superclass when implementing a subclass of it.</p>
		</div>
		
		<a name="5_5"></a>
		<h2 class="heading2" title="5. Scrunch-related Problems -&gt; 5.5. Private Identifiers Inside String Literals"><span class="headingNumber"><a href="#5" title="5. Scrunch-related Problems">5</a>.<a href="#5_5" title="5. Scrunch-related Problems -&gt; 5.5. Private Identifiers Inside String Literals">5</a>. </span>Private Identifiers Inside String Literals</h2>
		<div class="contents2">
			<p>The Scruncher does not enter string literals. This means that any code contained inside string literals will not be scrunched.</p>
			
			<p><span class="allCaps">A HYPOTHETICAL SCENARIO</span></p>
			
			<p>For performance reasons, you might want to dynamically build a function that will get executed repeatedly, rather than repeatedly performing the same conditional steps. By building a function, you can capture how the code that you need to repeatedly execute is conditionalized based upon some state that remains the same throughout the entire iteration. Now, let's say you wanted your dynamically built function to call private functions or methods. If you use the private identifiers when constructing your function's body, your function will work with source code but will fail with scrunched code.</p>
			
			<p>So, if you're putting code into string literals - either to be evaluated using JavaScript's built-in <code>eval</code> function, or to be built into a function using JavaScript's <code><a href="../javascript-reference/Function.html">Function</a></code> object - you will either need to make public the identifiers that need to be accessed from the code inside string literals, or you will need to use a trick to "pipe" the scrunched name into the dynamically constructed JavaScript code.</p>
			
			<p>The following example is <b>not</b> a good, real world example, but it does illustrate the point quite clearly...</p>
			
			<p><span class="allCaps">SOURCE CODE - IT WORKS</span></p>
			
			
<pre class="sample-code">function _myFunction () {
  var _myVariable = 'Hello there';
  eval ('alert (_myVariable)');
}
</pre>
			
			<p><span class="allCaps">SCRUNCHED CODE - IT FAILS!!!</span></p>
			
			
<pre class="sample-code">function _a(){var _b='Hello there';eval('alert (_myVariable)');}
</pre>
			
			<p>To fix the problem, you could do one of the following...</p>
			
			<a name="5_5_1"></a>
			<h3 class="heading3" title="5. Scrunch-related Problems -&gt; 5.5. Private Identifiers Inside String Literals -&gt; 5.5.1. Avoid Privates"><span class="headingNumber"><a href="#5" title="5. Scrunch-related Problems">5</a>.<a href="#5_5" title="5. Scrunch-related Problems -&gt; 5.5. Private Identifiers Inside String Literals">5</a>.<a href="#5_5_1" title="5. Scrunch-related Problems -&gt; 5.5. Private Identifiers Inside String Literals -&gt; 5.5.1. Avoid Privates">1</a>. </span>Avoid Privates</h3>
			<div class="contents3">
				<p>Make public the identifiers that need to be accessed from the code inside string literals, as in...</p>
				
				<p><span class="allCaps">SOURCE CODE - IT WORKS</span></p>
				
				
<pre class="sample-code">function _myFunction () {
  var myVariable = 'Hello there';
  eval ('alert (myVariable)');
}
</pre>
				
				<p><span class="allCaps">SCRUNCHED CODE - NOW IT WORKS</span></p>
				
				
<pre class="sample-code">function _a(){var myVariable='Hello there';eval('alert (myVariable)');}
</pre>
			</div>
			
			<a name="5_5_2"></a>
			<h3 class="heading3" title="5. Scrunch-related Problems -&gt; 5.5. Private Identifiers Inside String Literals -&gt; 5.5.2. Pipe the Privates Through"><span class="headingNumber"><a href="#5" title="5. Scrunch-related Problems">5</a>.<a href="#5_5" title="5. Scrunch-related Problems -&gt; 5.5. Private Identifiers Inside String Literals">5</a>.<a href="#5_5_2" title="5. Scrunch-related Problems -&gt; 5.5. Private Identifiers Inside String Literals -&gt; 5.5.2. Pipe the Privates Through">2</a>. </span>Pipe the Privates Through</h3>
			<div class="contents3">
				<p>Use the trick to "pipe" the scrunched name into dynamically constructed JavaScript code, as in...</p>
				
				<p><span class="allCaps">SOURCE CODE - IT WORKS</span></p>
				
				
<pre class="sample-code">function _myFunction () {
  var _myVariable = 'Hello there';
  for (var _myVariablePrivateName in {_myVariable:1});
  eval ('alert (' + _myVariablePrivateName + ')');
}
</pre>
				
				<p><span class="allCaps">SCRUNCHED CODE - NOW IT WORKS</span></p>
				
				
<pre class="sample-code">function _a(){var _b='Hello there';for(var _c in{_b:1});eval('alert ('+_c+')');}
</pre>
				
				<p>You would never use this technique for such an absurdly trivial case, but in more sophisticated code where you're dynamically constructing JavaScript code to <code>eval</code> or turn into a <code><a href="../javascript-reference/Function.html">Function</a></code> instance, this technique may come in handy. It works because the <code>for...in</code> loop iterates through the keys of an object that only has one key, where that key is the name of an identifier that will be scrunched. The loop itself does nothing, but the iterator variable is left with the name of the key after the one iteration loop has completed. When the code is scrunched, the key will be different. Using this trick, you've put an identifier name into a string variable - and it works regardless of how the private identifier is changed during scrunching.</p>
			</div>
		</div>
	</div>
	
	<a name="6"></a>
	<h1 class="heading1" title="6. Accidental Globals"><span class="headingNumber"><a href="#6" title="6. Accidental Globals">6</a>. </span>Accidental Globals</h1>
	<div class="contents1">
		<p>Accidental globals are variables that are accidentally assigned in the global scope - usually the result of a bug / oversight.</p>
		
		<p>It pays to be vigilant regarding accidental assignment of global variables. It's quite easy to accidentally assign a global variable, just by forgetting a <code>var</code> keyword in a critical place. Sometimes an accidental global can lie dormant for a long time - lurking in the shadows, so to speak - before actually causing a problem.</p>
		
		<a name="6_1"></a>
		<h2 class="heading2" title="6. Accidental Globals -&gt; 6.1. The Problems They Create"><span class="headingNumber"><a href="#6" title="6. Accidental Globals">6</a>.<a href="#6_1" title="6. Accidental Globals -&gt; 6.1. The Problems They Create">1</a>. </span>The Problems They Create</h2>
		<div class="contents2">
			<p>The kinds of problem situations that can arise as a result of accidental global include...</p>
			
			<a name="6_1_1"></a>
			<h3 class="heading3" title="6. Accidental Globals -&gt; 6.1. The Problems They Create -&gt; 6.1.1. Collisions Between Different Instances of a Closure"><span class="headingNumber"><a href="#6" title="6. Accidental Globals">6</a>.<a href="#6_1" title="6. Accidental Globals -&gt; 6.1. The Problems They Create">1</a>.<a href="#6_1_1" title="6. Accidental Globals -&gt; 6.1. The Problems They Create -&gt; 6.1.1. Collisions Between Different Instances of a Closure">1</a>. </span>Collisions Between Different Instances of a Closure</h3>
			<div class="contents3">
				<p>Different instances of the same closure can stomp over state that wasn't intended to be shared.</p>
				
				<p>In this scenario, one piece of code is implemented so that a closure inside it is expecting a particular variable in its enclosing scope to persist a unique value for each instance of the closure. Accidentally assigned as a global, different closure instances stomp on each other by assigning to that same global variable when they thought they were using an instance of the variable unique to them. Strange behavior can ensue.</p>
			</div>
			
			<a name="6_1_2"></a>
			<h3 class="heading3" title="6. Accidental Globals -&gt; 6.1. The Problems They Create -&gt; 6.1.2. Collisions Between Disparate Code"><span class="headingNumber"><a href="#6" title="6. Accidental Globals">6</a>.<a href="#6_1" title="6. Accidental Globals -&gt; 6.1. The Problems They Create">1</a>.<a href="#6_1_2" title="6. Accidental Globals -&gt; 6.1. The Problems They Create -&gt; 6.1.2. Collisions Between Disparate Code">2</a>. </span>Collisions Between Disparate Code</h3>
			<div class="contents3">
				<p>Two different pieces of code - possibly in the same module or from completely different modules in use by the page - can stomp over state that wasn't intended to be shared.</p>
				
				<a name="6_1_2_1"></a>
				<h4 class="heading4" title="6. Accidental Globals -&gt; 6.1. The Problems They Create -&gt; 6.1.2. Collisions Between Disparate Code -&gt; 6.1.2.1. Works in Source, Fails in Scrunched"><span class="headingNumber"><a href="#6" title="6. Accidental Globals">6</a>.<a href="#6_1" title="6. Accidental Globals -&gt; 6.1. The Problems They Create">1</a>.<a href="#6_1_2" title="6. Accidental Globals -&gt; 6.1. The Problems They Create -&gt; 6.1.2. Collisions Between Disparate Code">2</a>.<a href="#6_1_2_1" title="6. Accidental Globals -&gt; 6.1. The Problems They Create -&gt; 6.1.2. Collisions Between Disparate Code -&gt; 6.1.2.1. Works in Source, Fails in Scrunched">1</a>. </span>Works in Source, Fails in Scrunched</h4>
				<div class="contents4">
					<p>In one scenario, two accidental globals have different names in source mode but get scrunched to the same identifier in scrunched mode.</p>
					
					<p>Now they stomp on each other, and one of the variables gets assigned a value that wasn't intended for it. Strange things ensue. The fundamental laws of physics are compromised. The universe collapses. In this scenario, you don't notice the problem caused by the accidental globals until you switch to production code (ie. scrunched code).</p>
				</div>
				
				<a name="6_1_2_2"></a>
				<h4 class="heading4" title="6. Accidental Globals -&gt; 6.1. The Problems They Create -&gt; 6.1.2. Collisions Between Disparate Code -&gt; 6.1.2.2. Fails in Source, Works in Scrunched"><span class="headingNumber"><a href="#6" title="6. Accidental Globals">6</a>.<a href="#6_1" title="6. Accidental Globals -&gt; 6.1. The Problems They Create">1</a>.<a href="#6_1_2" title="6. Accidental Globals -&gt; 6.1. The Problems They Create -&gt; 6.1.2. Collisions Between Disparate Code">2</a>.<a href="#6_1_2_2" title="6. Accidental Globals -&gt; 6.1. The Problems They Create -&gt; 6.1.2. Collisions Between Disparate Code -&gt; 6.1.2.2. Fails in Source, Works in Scrunched">2</a>. </span>Fails in Source, Works in Scrunched</h4>
				<div class="contents4">
					<p>In another scenario, two accidental globals may "collide" when using source / unscrunched code, but may not collide when the scrunched version of the code is used.</p>
					
					<p>This is a more likely scenario than the <a href="#6_1_2_1">Works in Source, Fails in Scrunched</a> scenario, because the probability of using the same name for a variable in two different pieces of code is higher than the probability of the same name being mapped to the same scrunched name in two different pieces of code. Fortunately, a problem that occurs in source code is more likely to be detected earlier, because development will be done using source / unscrunched code.</p>
				</div>
			</div>
			
			<a name="6_1_3"></a>
			<h3 class="heading3" title="6. Accidental Globals -&gt; 6.1. The Problems They Create -&gt; 6.1.3. Collisions With Page Code"><span class="headingNumber"><a href="#6" title="6. Accidental Globals">6</a>.<a href="#6_1" title="6. Accidental Globals -&gt; 6.1. The Problems They Create">1</a>.<a href="#6_1_3" title="6. Accidental Globals -&gt; 6.1. The Problems They Create -&gt; 6.1.3. Collisions With Page Code">3</a>. </span>Collisions With Page Code</h3>
			<div class="contents3">
				<p>Code inside a module can accidentally assign a value on a global variable that is also used by the page code, when the module actually needs to be using a local scope variable.</p>
				
				<p>Because module code is often intended to be scrunched and because identifiers are, therefore, often prefixed with an underscore, it is less likely for this scenario to arise. Typically, global variables that are assigned in the page that are part of the very page-specific code are not intended to be scrunched (since the code may not be in an external file) and are not likely to be prefixed with an underscore.</p>
			</div>
		</div>
		
		<a name="6_2"></a>
		<h2 class="heading2" title="6. Accidental Globals -&gt; 6.2. How They Creep In"><span class="headingNumber"><a href="#6" title="6. Accidental Globals">6</a>.<a href="#6_2" title="6. Accidental Globals -&gt; 6.2. How They Creep In">2</a>. </span>How They Creep In</h2>
		<div class="contents2">
			<p>The most obvious way to assign an accidental global is to simply forget the <code>var</code> keyword in front of a plain old variable declaration / assignment.</p>
			
			<p>However, more insidious traps are waiting to ensnare you.</p>
			
			<a name="6_2_1"></a>
			<h3 class="heading3" title="6. Accidental Globals -&gt; 6.2. How They Creep In -&gt; 6.2.1. Incorrect Semicolon in Compound var Statement"><span class="headingNumber"><a href="#6" title="6. Accidental Globals">6</a>.<a href="#6_2" title="6. Accidental Globals -&gt; 6.2. How They Creep In">2</a>.<a href="#6_2_1" title="6. Accidental Globals -&gt; 6.2. How They Creep In -&gt; 6.2.1. Incorrect Semicolon in Compound var Statement">1</a>. </span>Incorrect Semicolon in Compound var Statement</h3>
			<div class="contents3">
				<p>Consider the following somewhat innocent looking compound <code>var</code> statement...</p>
				
				<p><span class="allCaps">EXAMPLE</span></p>
				
				
<pre class="sample-code">var
  myVariable1 = 1,
  myVariable2 = 2,
  myVariable3 = 3;
  myVariable4 = 4,
  myVariable5 = 5
;
</pre>
				
				<p>It's easy to miss, but there's a semicolon at the end of the assignment to <code>myVariable3</code>. You don't get any kind of error, because what follows is syntactically correct in JavaScript. However, you have terminated the compound <code>var</code> statement, and the assignments of <code>myVariable4</code> and <code>myVariable5</code> are now as globals because they have no <code>var</code> keyword at the beginning of the statement.</p>
			</div>
			
			<a name="6_2_2"></a>
			<h3 class="heading3" title="6. Accidental Globals -&gt; 6.2. How They Creep In -&gt; 6.2.2. Missing var statement in Loops"><span class="headingNumber"><a href="#6" title="6. Accidental Globals">6</a>.<a href="#6_2" title="6. Accidental Globals -&gt; 6.2. How They Creep In">2</a>.<a href="#6_2_2" title="6. Accidental Globals -&gt; 6.2. How They Creep In -&gt; 6.2.2. Missing var statement in Loops">2</a>. </span>Missing var statement in Loops</h3>
			<div class="contents3">
				<p>A slightly more obvious, yet surprisingly easy-to-make mistake is to omit a <code>var</code> keyword in a loop, particularly with <code>for...in</code> loops.</p>
				
				<p>Whereas a normal <code>for</code> loop has three statements that don't read like English all that well, a <code>for...in</code> loop reads more elegantly - and therein lies the trap. It's easier to think <code>for (key in object)</code> than it is to think <code>for (var key in object)</code>, since the latter sounds more clumsy. As silly as it sounds, the semantics of it does seem to play a role.</p>
				
				<p><span class="allCaps">EXAMPLE 1</span></p>
				
				
<pre class="sample-code">for (_elementNo = -1; ++_elementNo &lt; _elements.length;) {
  // ...
  // ...
}
</pre>
				
				<p><span class="allCaps">EXAMPLE 2</span></p>
				
				
<pre class="sample-code">for (_key in _object) {
  // ...
  // ...
}
</pre>
			</div>
		</div>
		
		<a name="6_3"></a>
		<h2 class="heading2" title="6. Accidental Globals -&gt; 6.3. How to Spot Accidental Globals"><span class="headingNumber"><a href="#6" title="6. Accidental Globals">6</a>.<a href="#6_3" title="6. Accidental Globals -&gt; 6.3. How to Spot Accidental Globals">3</a>. </span>How to Spot Accidental Globals</h2>
		<div class="contents2">
			<p>Accidental globals can be spotted by keeping an eye on the DOM in a debugging tool such as <a href="http://getfirebug.com" target="_blank" class="externalSiteLink">Firebug</a>.</p>
			
			<a name="6_3_1"></a>
			<h3 class="heading3" title="6. Accidental Globals -&gt; 6.3. How to Spot Accidental Globals -&gt; 6.3.1. Thorough Interaction"><span class="headingNumber"><a href="#6" title="6. Accidental Globals">6</a>.<a href="#6_3" title="6. Accidental Globals -&gt; 6.3. How to Spot Accidental Globals">3</a>.<a href="#6_3_1" title="6. Accidental Globals -&gt; 6.3. How to Spot Accidental Globals -&gt; 6.3.1. Thorough Interaction">1</a>. </span>Thorough Interaction</h3>
			<div class="contents3">
				<p>In order to be certain that you've spotted all the lurking accidental globals, you may need to pound away at the functionality in your pages.</p>
				
				<p>Some accidental globals may be lurking in the "nooks and crannies" of your code, and so you may need to interact with your pages a lot before being able to reliably assess the number of them that exist. You really want to hit all the code that could ever possibly be hit in your pages before you draw your conclusions. You want to push at all the states and conditions that could arise through a wide range of possible user interaction.</p>
			</div>
			
			<a name="6_3_2"></a>
			<h3 class="heading3" title="6. Accidental Globals -&gt; 6.3. How to Spot Accidental Globals -&gt; 6.3.2. Using Firebug"><span class="headingNumber"><a href="#6" title="6. Accidental Globals">6</a>.<a href="#6_3" title="6. Accidental Globals -&gt; 6.3. How to Spot Accidental Globals">3</a>.<a href="#6_3_2" title="6. Accidental Globals -&gt; 6.3. How to Spot Accidental Globals -&gt; 6.3.2. Using Firebug">2</a>. </span>Using Firebug</h3>
			<div class="contents3">
				<p>Keep <a href="http://getfirebug.com" target="_blank" class="externalSiteLink">Firebug</a> open while browsing pages of your site and have the DOM tab selected.</p>
				
				<p>From the Options drop-down to the right, make sure at least the "Show User-defined Properties" and "Show User-defined Functions" options are both checked - the rest can be disabled (which may even be helpful in reducing clutter).</p>
				
				<p>Now, as you browse pages in this state, keep an eye on what global identifiers show up in the DOM listing. You can expect to see some <code>$</code> variables (for the declarative syntax for widget data and widget adoption), the <code><a href="../reference/Uize.html">Uize</a></code> namespace, the global page widget variable, and possibly some intentional globals that are nevertheless an indication of bad / old school design patterns. What you shouldn't see are variables that start with an underscore - those are almost certainly variables that are supposed to be locals in functions but that are being accidentally assigned globally.</p>
				
				<p><b>IMPORTANT:</b> As you interact with your pages to provoke the possible assignment of accidental globals, be sure to use the "Refresh" option from Firebug's Options drop-down to the right - new additions to the DOM resulting from interaction won't automatically show up.</p>
			</div>
		</div>
		
		<a name="6_4"></a>
		<h2 class="heading2" title="6. Accidental Globals -&gt; 6.4. Fixing Accidental Globals"><span class="headingNumber"><a href="#6" title="6. Accidental Globals">6</a>.<a href="#6_4" title="6. Accidental Globals -&gt; 6.4. Fixing Accidental Globals">4</a>. </span>Fixing Accidental Globals</h2>
		<div class="contents2">
			<p>It can be hard to fix an accidental global, because there's no easy way to know where its assignment is originating from.</p>
			
			<p>Unless it's obvious from the name of the variable, one may have to do a global search (how ironic!) through the JavaScript code. The process of tracing the origin of an accidental global assignment can be complicated for variables with generic names that are used in multiple places, such as <code>_result</code>, <code>_object</code>, <code>_key</code>, <code>_property</code>, <code>_params</code>, etc.</p>
			
			<p>Having to hunt down the source of accidental globals can be avoided, of course, if you keep a watchful eye on the DOM as you develop code. That way, you'll notice the accidental globals sooner after they creep in and will have a better idea of what recent code changes may have introduced them.</p>
		</div>
	</div>
</div>

</div>

<script type="text/javascript">

Uize.module ({
	required:[
		'UizeSite.Page.Doc.library',
		'UizeSite.Page.Doc'
	],
	builder:function () {(window.page = UizeSite.Page.Doc ()).wireUi ()}
});

</script>

</body></html>



